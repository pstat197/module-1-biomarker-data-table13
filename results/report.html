<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lucas Childs, Minu Pabbathi, Nathan Kim, Bahaar Ahuja, Anna Liang">
<meta name="dcterms.date" content="2025-11-06">

<title>Biomarkers of ASD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-16bbabe37efa2ecafad14e96199f1a13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Biomarkers of ASD</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lucas Childs, Minu Pabbathi, Nathan Kim, Bahaar Ahuja, Anna Liang </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 6, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>This report investigates blood biomarkers for autism spectrum disorder (ASD) with a focus on evaluating how methodological choices influence results. Using the dataset from Hewitson et al.&nbsp;(2021), we examine protein distributions and justify the use of log-transformations to stabilize variance and reduce skewness. We explore subject-level outliers and assess whether their frequency differs between ASD and typically developing (TD) groups. We then evaluate how modifications to protein selection procedures, such as varying the number of top predictive proteins, using training/test partitions, and applying fuzzy intersections, affect classification performance. Finally, we identify alternative protein panels that achieve comparable or improved classification accuracy and benchmark these results against the original in-class analysis. This work highlights the sensitivity of biomarker analyses to preprocessing and methodological decisions and provides guidance for more robust ASD protein panel selection.</p>
</section>
<section id="aim" class="level2">
<h2 class="anchored" data-anchor-id="aim">Aim</h2>
<p>The aim of this report is to explore the sensitivity of ASD biomarker analyses to key methodological choices. Specifically, we examine the effects of log-transforming protein levels, assess the presence of subject-level outliers and their group distribution, and investigate how modifications to protein selection procedures (e.g., training/test splits, number of top proteins, fuzzy intersections) impact classification performance. Finally, we identify alternative protein panels that achieve comparable or improved classification accuracy and benchmark these results against the original in-class analysis.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>The data consist of blood serum samples from 76 boys with autism spectrum disorder (ASD) and 78 typically developing (TD) boys, aged 18 months to 8 years. Proteomic analysis was performed using SomaLogic’s SOMAScan™ 1.3K platform, measuring levels of 1,317 proteins. Two additional variables, ADOS (ASD severity) and group (ASD vs.&nbsp;TD), were included.</p>
<p>Preprocessing involved removing missing values, applying a log₁₀ transformation to stabilize variance and reduce skewness, centering and scaling each protein to standardize distributions, and trimming extreme outliers to prevent disproportionate influence. For exploratory analyses, we also considered an untrimmed dataset to examine subject-level outliers.</p>
</section>
<section id="summary-of-published-analysis" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-published-analysis">Summary of published analysis</h2>
<p>The original researchers used multiple <em>t</em>-tests to see whether there were significant differences in protein levels between the ASD group and the neurotypical group. Based on those <em>t</em> values, the top 10 proteins were selected for the prediction model. Each protein was also correlated with ADOS scores and the top 10 highly correlated proteins were selected. The third approach was random forest, which involves using a random forest to predict whether a participant has ASD or is typically developing. By keeping track of which variables were used most to define splits, a variable importance score can be used to determine which predictors were most influential in prediction. Using this method, the top proteins were selected.</p>
<p>After running all three methods and determining the top 10 proteins for each method, 5 proteins that were common to all three methods were selected as the core proteins. Each of the other proteins were added one at a time to see their impact on the AUC, leading to about four additional proteins being classified as optimal proteins. The final 9 proteins were IgD, suPAR, MAPK14, EPHB2, DERM, ROR1, GI24, elF-4H, and ARSB. After all nine were combined, the AUC of the classifier was approximately 0.860.</p>
<p>Below is a flowchart of this process.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/flowchart.png" class="img-fluid quarto-figure quarto-figure-left figure-img" alt="Question 1 comparison" width="500"></p>
</figure>
</div>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">Findings</h2>
<section id="impact-of-preprocessing-and-outliers" class="level3">
<h3 class="anchored" data-anchor-id="impact-of-preprocessing-and-outliers">Impact of preprocessing and outliers</h3>
<p>After looking at the raw protein level distributions for a sample of 4 proteins in the dataset, it became clear that the scale of each protein level was very different across proteins. For example, one protein’s mean was 17,164 while another’s was 458. Furthermore, we found certain proteins had skewed distributions where one protein had a mean roughly 5,000 units larger than its median, indicating a right skew. Looking at each protein’s density further revealed the differing scales of each protein level, large outliers, and skewed distributions apparent in 2 out of the 4 randomly selected proteins.</p>
<p>The log transformation of the protein levels helps to compress the scale of protein levels across the wide range of positive values that were encountered. Additionally, the logarithm helps with skewed data, helping to make data more symmetric and closer to a normal distribution (as confirmed with histograms and a QQ Plot).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Q1Comparison%20copy.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>From the density plot, <code>prot2</code> looks skewed (strongly right-skewed). It contain large outliers, and the scale of <code>prot2</code>’s protein level is very high. But, after log transforming, the right-skewed <code>prot2</code> now appears more symmetric and of a much smaller and more readable scale.</p>
<p><strong>Task 2:</strong> After removing the original trimming, we flagged protein-level outliers at <span class="math inline">\(|z|&gt;3\)</span>, where 99.7% of data is captured under a normal curve. Using the Tukey cutoff <span class="math inline">\((Q3 + 1.5\cdot IQR \approx 29.4)\)</span>, the 154 test subjects were considered outliers if they had <span class="math inline">\(\geq 30\)</span> outlier proteins. This flagged 13 outlier subjects, as listed below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/q2top13.png" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="Question 1 comparison" width="115"></p>
</figure>
</div>
<p>The frequency of these outlier subjects are <span class="math inline">\(\frac{4}{76} \approx 5.3\%\)</span> in the ASD group and <span class="math inline">\(\frac{9}{78} \approx 11.5\%\)</span> in the TD group.</p>
<p>We then compared the number of outlier proteins for subjects across both groups.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/q2boxplot.png" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="Question 1 comparison" width="450"></p>
</figure>
</div>
<p>From the visual, it seems like the TD group has more subjects w/ higher outlier counts, including the overall maximum around 150. This supports the previous table, as 9/13 of the outlier subjects were from the TD group.</p>
<p>Although the table and box plots showed that outlier subjects were more common in TD than ASD, a further two-proportion test found no statistically significant difference in this frequency of outlier subjects between both groups.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/q2proptest.png" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="Question 1 comparison" width="150"></p>
</figure>
</div>
<p>Since the p value of 0.2668 is greater than alpha = 0.05, we conclude there’s no statistically significant difference in the frequency of outlier subjects between ASD and TD. This suggests that extreme values are concentrated in a small number of individuals rather than representing a systematic group difference. These findings support the validity of the original trimming approach. The extreme values appear to be leverage points or noise rather than having significant impact, and the <span class="math inline">\(\pm 3\)</span> SD trimming in the initial dataset is appropriate. Thus, we can proceed with the original trimmed dataset for our analysis.</p>
</section>
<section id="methodological-variations" class="level3">
<h3 class="anchored" data-anchor-id="methodological-variations">Methodological variations</h3>
<p>To evaluate the sensitivity of the analysis to different methodological choices, we first modified the workflow so that all feature selection was carried out exclusively on a training partition, while a separate test set was held out and used only once at the very end for evaluation. This change avoids data leakage and gives a more realistic estimate of model performance.</p>
<p>The original analysis selected 10 proteins. To improve the predictive ability, we extended this to 20 proteins. The top 20 proteins from the <em>t</em>-tests and random forest were used to fit a logistic regression model. This improved the sensitivity by 6%, specificity by 13%, accuracy by 9%, and AUC by 4%, likely because adding more predictors will explain more of the variability.</p>
<p>Additionally, instead of using a hard intersection between the top 10 proteins, we tested using a fuzzy intersection, meaning we allowed some overlap between proteins from both analyses. The new analysis decreased the sensitivity by 20%, specificity by 7%, accuracy by 10%, and AUC by 12%. This could be because proteins that were found to be important in both analysis likely had the highest predictive power. When using other proteins that are less explanative, the accuracy decreases significantly.</p>
<p><img src="images/q3_plot_1%20copy.png" class="img-fluid" style="width:50.0%"></p>
<p><img src="images/q3_plot_2%20copy.png" class="img-fluid" style="width:50.0%"></p>
</section>
<section id="improved-classifier" class="level3">
<h3 class="anchored" data-anchor-id="improved-classifier">Improved classifier</h3>
<p>We explored two distinct alternative panel approaches for Task 4: a Pure LASSO approach and a Guided LASSO approach, benchmarking both against the original In-class Intersection model (a 5-protein panel). Our methods sought either a comparable simpler panel or an alternative panel with improved classification performance. The Pure LASSO approach used LASSO penalized regression for both feature selection and final classification, resulting in a 43-protein panel.</p>
<p>The Guided LASSO approach took proteins identified through both multiple testing with t-tests and Random Forest importance (<code>proteins_sstar</code>) and assigned them zero penalty to ensure these were included in the panel without significant shrinkage due to regularization. So, there was this prior validation used because there was strong prior evidence that these proteins were relevant. The remaining proteins not selected by the two aforementioned methods received L1 regularization (LASSO regularization), allowing us to discover additional predictive biomarkers while controlling overfitting. We can think of this method from a Bayesian standpoint where the prior data (pre-selected panel of 5 proteins, <code>proteins_sstar</code>) informed our belief about protein importance. Overall, our method displayed increased classification accuracy, specifically highlighted by the metric: ‘accuracy’. The metrics are depicted below:</p>
<p><strong>Guided LASSO performance metrics:</strong></p>
<p><span class="math display">\[
\begin{array}{llr}
\hline
\textbf{metric} &amp; \textbf{estimator} &amp; \textbf{estimate} \\
\hline
\text{sensitivity} &amp; \text{binary} &amp; 0.750 \\
\text{specificity} &amp; \text{binary} &amp; 0.933 \\
\text{accuracy} &amp; \text{binary} &amp; 0.839 \\
\text{roc auc} &amp; \text{binary} &amp; 0.858 \\
\hline
\end{array}
\]</span></p>
<p>Compared to the <span class="math inline">\(\underline{benchmark}\)</span> results: <span class="math display">\[
\begin{array}{llr}
\hline
\textbf{metric} &amp; \textbf{estimator} &amp; \textbf{estimate} \\
\hline
\text{sensitivity} &amp; \text{binary} &amp; 0.812 \\
\text{specificity} &amp; \text{binary} &amp; 0.733 \\
\text{accuracy} &amp; \text{binary} &amp; 0.774 \\
\text{roc auc} &amp; \text{binary} &amp; 0.883 \\
\hline
\end{array}
\]</span> Thus, the Guided LASSO approach made roughly an <span class="math inline">\(8\%\)</span> decrease in sensitivity, <span class="math inline">\(27\%\)</span> increase in specificity, <span class="math inline">\(8\%\)</span> increase in accuracy, and <span class="math inline">\(3\%\)</span> decrease in AUC. This method found a panel of 35 proteins which resulted in better ability of identifying true negatives and greater ability to recognize both true positives and true negatives out of all test results. The proteins selected for the classifier were:</p>
<ul>
<li>CD59</li>
<li>4-1BB</li>
<li>Dtk</li>
<li>Cadherin-5</li>
<li>HAI-1</li>
<li>Kallikrein 11</li>
<li>PAI-1</li>
<li>Growth hormone receptor</li>
<li>IGFBP-4</li>
<li>MRC2</li>
<li>CRDL1</li>
<li>IL-17 RD</li>
<li>TPSG1</li>
<li>MP2K2</li>
<li>ENPP7</li>
<li>MFGM</li>
<li>PCSK7</li>
<li>ITI heavy chain H4</li>
<li>IgD</li>
<li>DBNL</li>
<li>DERM</li>
<li>Elafin</li>
<li>RELT</li>
<li>PPID</li>
<li>Semaphorin 3E</li>
<li>CD27</li>
<li>CNDP1</li>
<li>IL-17 RC</li>
<li>SRCN1</li>
<li>Epo</li>
<li>GDNF</li>
<li>14-3-3 protein zeta/delta</li>
<li>a-Synuclein</li>
<li>CSRP3</li>
<li>MIG</li>
</ul>
<p>Before attempting the Guided LASSO approach we implemented a pure LASSO model (giving the same L1 penalty to all proteins) with the given metrics:</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Comparative Performance and Insights: Pure LASSO vs.&nbsp;In-class Baseline</caption>
<colgroup>
<col style="width: 9%">
<col style="width: 18%">
<col style="width: 9%">
<col style="width: 21%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Metric</th>
<th style="text-align: center;">In-class Intersection</th>
<th style="text-align: center;">Pure LASSO</th>
<th style="text-align: center;">Change vs.&nbsp;Baseline</th>
<th style="text-align: center;">Key Insight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Accuracy</td>
<td style="text-align: center;">0.774</td>
<td style="text-align: center;">0.767</td>
<td style="text-align: center;"><span class="math inline">\(\approx 1\%\)</span> decrease</td>
<td style="text-align: center;">Comparable overall accuracy.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sensitivity</td>
<td style="text-align: center;">0.812</td>
<td style="text-align: center;">0.800</td>
<td style="text-align: center;"><span class="math inline">\(1.5\%\)</span> decrease</td>
<td style="text-align: center;">Reduced ability to correctly identify ASD cases.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Specificity</td>
<td style="text-align: center;">0.733</td>
<td style="text-align: center;">0.733</td>
<td style="text-align: center;">constant</td>
<td style="text-align: center;">Unchanged performance in ruling out controls.</td>
</tr>
<tr class="even">
<td style="text-align: left;">AUROC</td>
<td style="text-align: center;">0.883</td>
<td style="text-align: center;">0.858</td>
<td style="text-align: center;"><span class="math inline">\(\approx 2.8\%\)</span> decrease</td>
<td style="text-align: center;">Lower overall discrimination ability.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Q4PureLasso%20copy.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Question 4 Pure LASSO</figcaption>
</figure>
</div>
<p>While the performance metrics for this model were similar to the baseline across all metrics, the overall strategy of combining multiple feature selection methods (t-tests, Random Forest, and Guided LASSO) provided a robust and statistically validated pathway to stable panel selection.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Our comprehensive analysis demonstrates the critical impact of methodological choices on blood biomarker classification performance for ASD. Key findings include the necessary use of log-transformation to manage data scale and skewness, and the finding that subject-level outliers did not significantly differ between ASD and TD groups, supporting the initial data trimming. Most significantly, our alternative panel approaches highlighted a crucial performance trade-off in Task 4:</p>
<p>The <strong>Pure LASSO</strong> model (43 proteins) sacrificed a small amount of overall discriminative ability (AUROC decreased by <span class="math inline">\(\approx 2.8\%\)</span>) and Accuracy (decreased by <span class="math inline">\(1\%\)</span>). The <strong>Guided LASSO</strong> approach provided a robust, multi-method validation pathway, resulting in a stable 35-protein panel with improved accuracy (<span class="math inline">\(8\%\)</span>) and specificity (<span class="math inline">\(27\%\)</span>) compared to the baseline.</p>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next Steps</h2>
<ol type="1">
<li>External Validation: Validate the Pure LASSO panel (or the Guided LASSO panel) on an independent, large-scale dataset to confirm the observed high Specificity and generalizability across different populations.</li>
<li>Biological Interpretation: Conduct a functional analysis of the 35 proteins selected by the Guided LASSO model to determine if they align with known biological pathways associated with ASD, thereby providing biological grounding for the statistical model.</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>